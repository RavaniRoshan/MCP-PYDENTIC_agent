from models import UserPrompt, TaskRequest, TaskExecutionPlan, BrowserAction, TaskResponse, ActionResult, ElementSelector
from core.config import settings
from core.safety import SafetyValidator, SafetyConfirmation
from utils.browser_init import get_browser_controller
import asyncio
import logging
from typing import List, Optional

logger = logging.getLogger(__name__)


class AutomateAIAgent:
    """
    Core agent that processes user requests and executes browser tasks
    """
    
    def __init__(self):
        self._browser_controller = None  # Will be initialized when needed
        self.safety_validator = SafetyValidator()
    
    @property
    async def browser_controller(self):
        if self._browser_controller is None:
            self._browser_controller = await get_browser_controller()
        return self._browser_controller
        
    async def process_task(self, task_request: TaskRequest) -> TaskResponse:
        """
        Main method to process a task request
        """
        logger.info(f"Processing task: {task_request.id}")
        
        task_response = TaskResponse(
            task_id=task_request.id,
            status="executing",
            request=task_request,
            started_at=task_request.created_at
        )
        
        try:
            # Plan the task execution
            execution_plan = await self.create_execution_plan(task_request)
            task_response.plan = execution_plan
            
            # Validate the plan for safety
            if not await self.safety_validator.validate_plan(execution_plan):
                task_response.status = "failed"
                task_response.error = "Task plan failed safety validation"
                return task_response
            
            # Execute the plan
            results = await self.execute_plan(execution_plan)
            task_response.results = results
            
            # Update final status
            if all(result.success for result in results):
                task_response.status = "completed"
            else:
                task_response.status = "failed"
                
        except Exception as e:
            logger.error(f"Error processing task {task_request.id}: {e}")
            task_response.status = "failed"
            task_response.error = str(e)
        
        return task_response
    
    async def create_execution_plan(self, task_request: TaskRequest) -> TaskExecutionPlan:
        """
        Create a step-by-step execution plan based on the user request
        """
        # This would typically call an AI model to generate the plan
        # For now, we'll return a more comprehensive placeholder plan
        plan_id = f"plan_{task_request.id}"
        
        # Placeholder implementation - in a real system, this would be generated by an AI
        actions: List[BrowserAction] = []
        
        prompt_lower = task_request.user_prompt.prompt.lower()
        
        # Simple rule-based approach for demonstration
        if "navigate to" in prompt_lower or "go to" in prompt_lower:
            # Extract URL from prompt (simple extraction for demo)
            import re
            urls = re.findall(r'https?://[^\s\'"<>]+', task_request.user_prompt.prompt)
            if urls:
                actions.append(BrowserAction(
                    id=f"action_{task_request.id}_1",
                    type="navigate",
                    value=urls[0],
                    description=f"Navigate to {urls[0]}"
                ))
        
        if "click" in prompt_lower or "button" in prompt_lower:
            # Add a click action
            actions.append(BrowserAction(
                id=f"action_{task_request.id}_2",
                type="click",
                element=ElementSelector(
                    type="text",
                    value="search",
                    description="Search button"
                ),
                description="Click on search button"
            ))
        
        # If we don't have specific instructions, add a default action
        if not actions:
            # Default action for demo purposes
            actions = [
                BrowserAction(
                    id=f"action_{task_request.id}_1",
                    type="navigate",
                    value="https://example.com",
                    description="Navigate to example.com"
                ),
                BrowserAction(
                    id=f"action_{task_request.id}_2",
                    type="click",
                    element=ElementSelector(
                        type="css",
                        value="a",  # First link
                        description="First link on the page"
                    ),
                    description="Click on first link"
                )
            ]
        
        return TaskExecutionPlan(
            id=plan_id,
            task_id=task_request.id,
            actions=actions,
            status="pending"
        )
    
    async def execute_plan(self, plan: TaskExecutionPlan) -> List[ActionResult]:
        """
        Execute the planned actions
        """
        results = []
        
        for action in plan.actions:
            result = await self.execute_action(action)
            results.append(result)
            
            # If an action fails, we might want to stop execution
            if not result.success:
                break
        
        return results
    
    async def execute_action(self, action: BrowserAction) -> ActionResult:
        """
        Execute a single browser action
        """
        try:
            browser = await self.browser_controller
            
            if action.type == "navigate":
                success = await browser.navigate(action.value or "", action.metadata.get("new_tab", False))
                result = f"Navigated to {action.value}" if success else "Navigation failed"
            elif action.type == "click":
                if action.element:
                    success = await browser.click(action.element, 
                                                 action.metadata.get("button", "left"), 
                                                 action.metadata.get("click_count", 1))
                    result = f"Clicked on {action.element.value}" if success else "Click failed"
                else:
                    return ActionResult(
                        action_id=action.id,
                        success=False,
                        error="Click action requires an element selector",
                        timestamp=action.created_at
                    )
            elif action.type == "type":
                if action.element and action.value:
                    success = await browser.type_text(action.element, str(action.value), 
                                                     action.metadata.get("clear", True))
                    result = f"Typed text into {action.element.value}" if success else "Type action failed"
                else:
                    return ActionResult(
                        action_id=action.id,
                        success=False,
                        error="Type action requires both an element selector and a value",
                        timestamp=action.created_at
                    )
            elif action.type == "extract":
                if action.element:
                    extracted_text = await browser.extract_text(action.element)
                    success = extracted_text is not None
                    result = extracted_text if success else "Extraction failed"
                else:
                    return ActionResult(
                        action_id=action.id,
                        success=False,
                        error="Extract action requires an element selector",
                        timestamp=action.created_at
                    )
            else:
                return ActionResult(
                    action_id=action.id,
                    success=False,
                    error=f"Unsupported action type: {action.type}",
                    timestamp=action.created_at
                )
            
            return ActionResult(
                action_id=action.id,
                success=success,
                result=result,
                timestamp=action.created_at
            )
        except Exception as e:
            return ActionResult(
                action_id=action.id,
                success=False,
                error=str(e),
                timestamp=action.created_at
            )


