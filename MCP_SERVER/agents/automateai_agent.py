from models import UserPrompt, TaskRequest, TaskExecutionPlan, BrowserAction, TaskResponse, ActionResult, ElementSelector
from core.config import settings
from core.safety import SafetyValidator, SafetyConfirmation
from utils.browser_init import get_browser_controller
import asyncio
import logging
from typing import List, Optional

logger = logging.getLogger(__name__)


class AutomateAIAgent:
    """
    The core agent responsible for processing user requests and executing browser tasks.

    This class orchestrates the entire process, from creating an execution plan
    to executing the plan and returning the results.
    """
    
    def __init__(self):
        """
        Initializes the AutomateAIAgent.
        """
        self._browser_controller = None  # Will be initialized when needed
        self.safety_validator = SafetyValidator()
    
    @property
    async def browser_controller(self):
        """
        Provides a browser controller instance, initializing it if necessary.
        """
        if self._browser_controller is None:
            self._browser_controller = await get_browser_controller()
        return self._browser_controller
        
    async def process_task(self, task_request: TaskRequest) -> TaskResponse:
        """
        The main method for processing a task request.

        Args:
            task_request (TaskRequest): The request to be processed.

        Returns:
            TaskResponse: The response to the task request.
        """
        logger.info(f"Processing task: {task_request.id}")
        
        task_response = TaskResponse(
            task_id=task_request.id,
            status="executing",
            request=task_request,
            started_at=task_request.created_at
        )
        
        try:
            # Plan the task execution
            execution_plan = await self.create_execution_plan(task_request)
            task_response.plan = execution_plan
            
            # Validate the plan for safety
            if not await self.safety_validator.validate_plan(execution_plan):
                task_response.status = "failed"
                task_response.error = "Task plan failed safety validation"
                return task_response
            
            # Execute the plan
            results = await self.execute_plan(execution_plan)
            task_response.results = results
            
            # Update final status
            if all(result.success for result in results):
                task_response.status = "completed"
            else:
                task_response.status = "failed"
                
        except Exception as e:
            logger.error(f"Error processing task {task_request.id}: {e}")
            task_response.status = "failed"
            task_response.error = str(e)
        
        return task_response
    
    async def create_execution_plan(self, task_request: TaskRequest) -> TaskExecutionPlan:
        """
        Creates a step-by-step execution plan based on the user request.

        Note: This is a placeholder implementation. In a real system, this would
        be generated by an AI model.

        Args:
            task_request (TaskRequest): The request to be processed.

        Returns:
            TaskExecutionPlan: The generated execution plan.
        """
        # This would typically call an AI model to generate the plan
        # For now, we'll return a more comprehensive placeholder plan
        plan_id = f"plan_{task_request.id}"
        
        # Placeholder implementation - in a real system, this would be generated by an AI
        actions: List[BrowserAction] = []
        
        prompt_lower = task_request.user_prompt.prompt.lower()
        
        # Simple rule-based approach for demonstration
        if "navigate to" in prompt_lower or "go to" in prompt_lower:
            # Extract URL from prompt (simple extraction for demo)
            import re
            urls = re.findall(r'https?://[^\s\'"<>]+', task_request.user_prompt.prompt)
            if urls:
                actions.append(BrowserAction(
                    id=f"action_{task_request.id}_1",
                    type="navigate",
                    value=urls[0],
                    description=f"Navigate to {urls[0]}"
                ))
        
        if "click" in prompt_lower or "button" in prompt_lower:
            # Add a click action
            actions.append(BrowserAction(
                id=f"action_{task_request.id}_2",
                type="click",
                element=ElementSelector(
                    type="text",
                    value="search",
                    description="Search button"
                ),
                description="Click on search button"
            ))
        
        # If we don't have specific instructions, add a default action
        if not actions:
            # Default action for demo purposes
            actions = [
                BrowserAction(
                    id=f"action_{task_request.id}_1",
                    type="navigate",
                    value="https://example.com",
                    description="Navigate to example.com"
                ),
                BrowserAction(
                    id=f"action_{task_request.id}_2",
                    type="click",
                    element=ElementSelector(
                        type="css",
                        value="a",  # First link
                        description="First link on the page"
                    ),
                    description="Click on first link"
                )
            ]
        
        return TaskExecutionPlan(
            id=plan_id,
            task_id=task_request.id,
            actions=actions,
            status="pending"
        )
    
    async def execute_plan(self, plan: TaskExecutionPlan) -> List[ActionResult]:
        """
        Executes the planned actions.

        Args:
            plan (TaskExecutionPlan): The execution plan.

        Returns:
            List[ActionResult]: A list of results for each executed action.
        """
        results = []
        
        for action in plan.actions:
            result = await self.execute_action(action)
            results.append(result)
            
            # If an action fails, we might want to stop execution
            if not result.success:
                break
        
        return results
    
    async def execute_action(self, action: BrowserAction) -> ActionResult:
        """
        Executes a single browser action.

        Args:
            action (BrowserAction): The action to be executed.

        Returns:
            ActionResult: The result of the action.
        """
        try:
            browser = await self.browser_controller
            
            if action.type == "navigate":
                success = await browser.navigate(action.value or "", action.metadata.get("new_tab", False))
                result = f"Navigated to {action.value}" if success else "Navigation failed"
            elif action.type == "click":
                if action.element:
                    success = await browser.click(action.element, 
                                                 action.metadata.get("button", "left"), 
                                                 action.metadata.get("click_count", 1))
                    result = f"Clicked on {action.element.value}" if success else "Click failed"
                else:
                    return ActionResult(
                        action_id=action.id,
                        success=False,
                        error="Click action requires an element selector",
                        timestamp=action.created_at
                    )
            elif action.type == "type":
                if action.element and action.value:
                    success = await browser.type_text(action.element, str(action.value), 
                                                     action.metadata.get("clear", True))
                    result = f"Typed text into {action.element.value}" if success else "Type action failed"
                else:
                    return ActionResult(
                        action_id=action.id,
                        success=False,
                        error="Type action requires both an element selector and a value",
                        timestamp=action.created_at
                    )
            elif action.type == "extract":
                if action.element:
                    extracted_text = await browser.extract_text(action.element)
                    success = extracted_text is not None
                    result = extracted_text if success else "Extraction failed"
                else:
                    return ActionResult(
                        action_id=action.id,
                        success=False,
                        error="Extract action requires an element selector",
                        timestamp=action.created_at
                    )
            else:
                return ActionResult(
                    action_id=action.id,
                    success=False,
                    error=f"Unsupported action type: {action.type}",
                    timestamp=action.created_at
                )
            
            return ActionResult(
                action_id=action.id,
                success=success,
                result=result,
                timestamp=action.created_at
            )
        except Exception as e:
            return ActionResult(
                action_id=action.id,
                success=False,
                error=str(e),
                timestamp=action.created_at
            )


